install.packages("stargazer")
library("stargazer")
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
install.packages("readxls")
library(readxl)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
install.packages("stargazer")
library(stargazer)
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
install.packages("stargazer")
library(stargazer)
rm(list = ls())
("stargazer")
library(stargazer)
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
install.packages("stargazer")
library(stargazer)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
install.packages("stargazer")
library(stargazer)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
summary(Data_statdesc)
#autres options avec un tableau plus agréable à lire
stargazer(Data_statdesc, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
install.packages("readxls")
install.packages("stargazer")
library(stargazer)
library(stargazer)
library(stargazer)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
library(readxl)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
summary(Data_statdesc)
#autres options avec un tableau plus agréable à lire
stargazer(Data_statdesc, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
library(stargazer)
install.packages("readxls")
###library
library(AER) # Functions, data sets, examples, demos, and vignettes for the book Christian Kleiber and Achim Zeileis (2008), Applied Econometrics with R, Springer-Verlag, New York
library(car) #car: Companion to Applied Regression
# Functions to Accompany J. Fox and S. Weisberg, An R Companion to Applied Regression, Third Edition, Sage, 2019.
library(sandwich) # Robust Covariance Matrix Estimators
library(lmtest) #Testing Linear Regression Models
#A collection of tests, data sets, and examples for diagnostic checking in linear regression models. Furthermore, some generic tools for inference in parametric models are provided
library(ggplot2) #Create Elegant Data Visualisations Using the Grammar of Graphics
library(corrplot) #Provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables
library(readxl)
library(stargazer)
library(stargazer)
install.packages("stargazer")
library(stargazer)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
rm(list = ls())
library(stargazer)
install.packages("stargazer")
setwd("~/econometrie")
library(stargazer)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
library(readxl)
# Récupération des données
data_TD3 <- read_excel("CO2_kuznets.xlsx")
names(data_TD3)[2] = "CO2pc"
names(data_TD3)[3] = "GDPpcppp"
names(data_TD3)[5] = "Energypc"
#Je vous propose Csi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
library(stargazer)
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
library(AER) # Functions, data sets, examples, demos, and vignettes for the book Christian Kleiber and Achim Zeileis (2008), Applied Econometrics with R, Springer-Verlag, New York
library(car) #car: Companion to Applied Regression
# Functions to Accompany J. Fox and S. Weisberg, An R Companion to Applied Regression, Third Edition, Sage, 2019.
library(sandwich) # Robust Covariance Matrix Estimators
library(lmtest) #Testing Linear Regression Models
#A collection of tests, data sets, and examples for diagnostic checking in linear regression models. Furthermore, some generic tools for inference in parametric models are provided
library(ggplot2) #Create Elegant Data Visualisations Using the Grammar of Graphics
library(corrplot) #Provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables
library(readxl)
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
data$Code<- as.integer(data$Code)
data$revenu_median_2021<- as.integer(data$revenu_median_2021)
data$Taux_de_pauvreté_2021<- as.integer(data$Taux_de_pauvreté_2021)
data$densité_med <- as.integer(data$densité_med)
data$`part_diplo_bac+3`<- as.integer(data$`part_diplo_bac+3`)
data$part_des_cadres_et_prof_2021 <-as.integer(data$part_des_cadres_et_prof_2021)
data$depas_seuil<- as.factor(data$depas_seuil)
data
summary(data)
# Convertir la dernière colonne en factor
#data[[ncol(data)]] <- as.factor(df[[ncol(data)]])
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
data$Code<- as.integer(data$Code)
data$revenu_median_2021<- as.integer(data$revenu_median_2021)
data$Taux_de_pauvreté_2021<- as.integer(data$Taux_de_pauvreté_2021)
data$densité_med <- as.integer(data$densité_med)
data$`part_diplo_bac+3`<- as.integer(data$`part_diplo_bac+3`)
data$part_des_cadres_et_prof_2021 <-as.integer(data$part_des_cadres_et_prof_2021)
data$depas_seuil<- as.factor(data$depas_seuil)
data
summary(data[-1])
# Convertir la dernière colonne en factor
#data[[ncol(data)]] <- as.factor(df[[ncol(data)]])
reg = lm(Espérance_de_vie_2021  ~ revenu_median_2021+Taux_de_pauvreté_2021+ part_diplo_bac_plus3 , data = data)
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
names(data[7])<- "part_diplo_bac_plus3"
data$Code<- as.integer(data$Code)
data$revenu_median_2021<- as.integer(data$revenu_median_2021)
data$Taux_de_pauvreté_2021<- as.integer(data$Taux_de_pauvreté_2021)
data$densité_med <- as.integer(data$densité_med)
data$part_diplo_bac_plus3<- as.integer(data$part_diplo_bac_plus3)
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
names(data[7])<- "part_diplo_bac_plus3"
data <-read_xlsx("dataeco.xlsx"  , row.names (1) )
names(data[7])<- "part_diplo_bac_plus3"
data$Code<- as.integer(data$Code)
data$revenu_median_2021<- as.integer(data$revenu_median_2021)
data$Taux_de_pauvreté_2021<- as.integer(data$Taux_de_pauvreté_2021)
data$densité_med <- as.integer(data$densité_med)
data$part_diplo_bac_plus3<- as.integer(data$part_diplo_bac_plus3)
getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
knitr::opts_chunk$set(echo = TRUE, message = FALSE, comment = NA)
AFC <- function(N){
Nind <- sum(N)
#a. calcul des metriques
Di <- diag(prop.table(rowSums(N)))
Dj <- diag(prop.table(colSums(N)))
#calculs des inverses et autres
DiInv <- diag(1/prop.table(rowSums(N)))
DjInv <- diag(1/prop.table(colSums(N)))
#calcul de Dj^{1/2} et son inverse
DjDemi <- diag(sqrt(colSums(prop.table(N))))
DjDemiInv <- diag(1/sqrt(colSums(prop.table(N))))
#b. tableau des frequences Z
vec_Z <- unlist(prop.table(N))
Z <- matrix(vec_Z, nrow(N), ncol(N))
#c. matrice des Ã©carts a l'independance X
X <- (DiInv %*% Z %*% DjInv) - 1
#d. calcul de la matrice V
V <- t(X) %*% Di %*% X
#e. vecteurs propres et mise en place de la matrice normee A
DjDemiVDjDemi <- DjDemi %*% V %*% DjDemi
#decomposition en vecteurs et valeurs propres
ll <- eigen(DjDemiVDjDemi, symmetric=TRUE)
r = length(ll$values[ll$values > 10^-10])
A <- DjDemiInv %*% ll$vectors[,1:r]
#f. determination des vecteurs propres DI-normes par la formule de transition
C <- matrix(0,nrow = nrow(N), r)
for (k in 1:r){
C[,k] <- 1/sqrt(ll$values[k]) * (X %*% Dj %*% A[,k])
}
#g. calcul du vecteur qui stocke le pourcentage d'inertie
inertieBrute <- ll$values
vec_prct_inertie <- as.vector(inertieBrute*100/sum(inertieBrute))
#h. calcul des coordonnees des lignes et colones
A_tilde <- matrix(0, nrow=ncol(N), r)
C_tilde <- matrix(0, nrow = nrow(N), r)
for (k in 1:r){
A_tilde[,k] <- sqrt(ll$values[k]) * A[,k]
C_tilde[,k] <- sqrt(ll$values[k]) * C[,k]
}
#i. liste des resultats
resu <- list(vec_prct_inertie,A,C,A_tilde,C_tilde)
return(resu)
}
graph_colones <- function(N){
afc_table <- AFC(N)
coord_colonnes <- afc_table[[4]]
par(pty = "s")
ecart <- c(min(afc_table[[4]]),max(afc_table[[4]]))
graph_colonne <- plot(coord_colonnes,pch=16,cex=.5,col='red',xlim=ecart,ylim=ecart,
xlab="Coordonnées sur axe 1",ylab="Coordonnées sur axe 2",
main="Coordonnées des colonnes du tableau de contingence")
abline(h=median(afc_table[[4]]),v=median(afc_table[[4]]),lty=15) #origine du graphique (0,0) et point moyen
return(graph_colonne)
}
bordeaux <- read.csv("bordeaux.csv", sep = ";")
bordeaux <- read.csv("bordeaux.csv", sep = ";")
AFC(bordeaux)
graph_lignes(bordeaux)
graph_lignes <- function(N){
afc_table <- AFC(N)
coord_lignes <- afc_table[[5]]
par(pty = "s")
ecart <- c(min(afc_table[[5]]),max(afc_table[[5]]))
graph_ligne <- plot(coord_lignes,pch=15,cex=.5,xlim=ecart,ylim=ecart,
xlab="Coordonnées sur axe 1",ylab="Coordonnées sur axe 2",
main="Coordonnées des lignes du tableau de contingence")
abline(h=median(afc_table[[5]]),v=median(afc_table[[5]]),lty=15) #origine du graphique (0,0) et point moyen
return(graph_ligne)
}
graph_colones <- function(N){
afc_table <- AFC(N)
coord_colonnes <- afc_table[[4]]
par(pty = "s")
ecart <- c(min(afc_table[[4]]),max(afc_table[[4]]))
graph_colonne <- plot(coord_colonnes,pch=16,cex=.5,col='red',xlim=ecart,ylim=ecart,
xlab="Coordonnées sur axe 1",ylab="Coordonnées sur axe 2",
main="Coordonnées des colonnes du tableau de contingence")
abline(h=median(afc_table[[4]]),v=median(afc_table[[4]]),lty=15) #origine du graphique (0,0) et point moyen
return(graph_colonne)
}
bordeaux <- read.csv("bordeaux.csv", sep = ";")
AFC(bordeaux)
graph_lignes(bordeaux)
graph_colones(bordeaux)
AFC <- function(N){
Nind <- sum(N)
#a. calcul des metriques
Di <- diag(prop.table(rowSums(N)))
Dj <- diag(prop.table(colSums(N)))
#calculs des inverses et autres
DiInv <- diag(1/prop.table(rowSums(N)))
DjInv <- diag(1/prop.table(colSums(N)))
#calcul de Dj^{1/2} et son inverse
DjDemi <- diag(sqrt(colSums(prop.table(N))))
DjDemiInv <- diag(1/sqrt(colSums(prop.table(N))))
#b. tableau des frequences Z
vec_Z <- unlist(prop.table(N))
Z <- matrix(vec_Z, nrow(N), ncol(N))
#c. matrice des Ã©carts a l'independance X
X <- (DiInv %*% Z %*% DjInv) - 1
#d. calcul de la matrice V
V <- t(X) %*% Di %*% X
#e. vecteurs propres et mise en place de la matrice normee A
DjDemiVDjDemi <- DjDemi %*% V %*% DjDemi
#decomposition en vecteurs et valeurs propres
ll <- eigen(DjDemiVDjDemi, symmetric=TRUE)
r = length(ll$values[ll$values > 10^-10])
A <- DjDemiInv %*% ll$vectors[,1:r]
#f. determination des vecteurs propres DI-normes par la formule de transition
C <- matrix(0,nrow = nrow(N), r)
for (k in 1:r){
C[,k] <- 1/sqrt(ll$values[k]) * (X %*% Dj %*% A[,k])
}
#g. calcul du vecteur qui stocke le pourcentage d'inertie
inertieBrute <- ll$values
vec_prct_inertie <- as.vector(inertieBrute*100/sum(inertieBrute))
#h. calcul des coordonnees des lignes et colones
A_tilde <- matrix(0, nrow=ncol(N), r)
C_tilde <- matrix(0, nrow = nrow(N), r)
for (k in 1:r){
A_tilde[,k] <- sqrt(ll$values[k]) * A[,k]
C_tilde[,k] <- sqrt(ll$values[k]) * C[,k]
}
#i. liste des resultats
resu <- list(vec_prct_inertie,A,C,A_tilde,C_tilde)
return(resu)
}
graph_lignes <- function(N){
afc_table <- AFC(N)
coord_lignes <- afc_table[[5]]
par(pty = "s")
ecart <- c(min(afc_table[[5]]),max(afc_table[[5]]))
graph_ligne <- plot(coord_lignes,pch=15,cex=.5,xlim=ecart,ylim=ecart,
xlab="Coordonnées sur axe 1",ylab="Coordonnées sur axe 2",
main="Coordonnées des lignes du tableau de contingence")
abline(h=median(afc_table[[5]]),v=median(afc_table[[5]]),lty=15) #origine du graphique (0,0) et point moyen
return(graph_ligne)
}
graph_colones <- function(N){
afc_table <- AFC(N)
coord_colonnes <- afc_table[[4]]
par(pty = "s")
ecart <- c(min(afc_table[[4]]),max(afc_table[[4]]))
graph_colonne <- plot(coord_colonnes,pch=16,cex=.5,col='red',xlim=ecart,ylim=ecart,
xlab="Coordonnées sur axe 1",ylab="Coordonnées sur axe 2",
main="Coordonnées des colonnes du tableau de contingence")
abline(h=median(afc_table[[4]]),v=median(afc_table[[4]]),lty=15) #origine du graphique (0,0) et point moyen
return(graph_colonne)
}
bordeaux <- read.csv("bordeaux.csv", sep = ";")
AFC(bordeaux)
graph_lignes(bordeaux)
graph_colones(bordeaux)
bordeaux <- read.csv("bordeaux.csv", sep = ";")
AFC(bordeaux)
graph_lignes(bordeaux)
graph_colones(bordeaux)
getwd()
head(diamond)
getwd()
getwd()
getwd()
a <- select(iris ,Petal.Width , Species)
library(dplyr)
library(ggplot2)
library(readr)
a <- select(iris ,Petal.Width , Species)
a
df <- filter(iris ,  Species == "versicolor" |  Species == "virginica")
df
df <- filter(iris , Species == "setosa")
nb_esp_setosa = summarise(df , nb_setosa = n())
nb_esp_setosa
df1 <- filter(iris,Species=="versicolor")
summarize(df,mean(Petal.Width))
df <- mutate(iris, Sum_Petal = Petal.Width + Sepal.Width)
df1 <- select(df, Petal.Width , Sepal.Width , Sum_Petal  )
df1
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
install.packages("tidygeocoder")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
ggplot(fr)+aes(x=long,y=lat) + geom_polygon(aes(group=group),fill="white",color="black")+ coord_quickmap()
fr <- map_data("senegal")
fr <- map_data("Senegal")
fr <- map_data("State")
fr <- map_data("state")
fr <- map_data("state")
ggplot(fr)+aes(x=long,y=lat) + geom_polygon(aes(group=group),fill="white",color="black")+ coord_quickmap()
fr <- map_data("canada")
ggplot(fr)+aes(x=long,y=lat) + geom_polygon(aes(group=group),fill="white",color="black")+ coord_quickmap()
fr <- map_data("canada")
ggplot(fr)+aes(x=long,y=lat) + geom_polygon(aes(group=group),fill="white",color="black")+ coord_quickmap()
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
data = read.csv("Fictive_medical_data.txt")
data = read.csv("Fictive_medical_data.txt")
library(factoextra)
library(cluster)
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
print(irs_data)
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
print(irs_data)
print(iris_data)
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Affichage du dendrogramme
plot(hc, labels = iris$Species, main = "Dendrogramme de la CAH")
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
# Affichage du dendrogramme
plot(hc, labels = iris$Species, main = "Dendrogramme de la CAH")
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "single link")
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
# Affichage du dendrogramme
plot(hc, labels = iris$Species, main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, iris$Species)
print(hc)
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, iris$Species)
plot(clusters)
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
print(hc)
# Affichage du dendrogramme
plot(hc, labels = iris$Species, main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, iris$Species)
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, k = 3 , method = "ward.D2")
# Exemple avec les données iris
data(iris)
iris_data <- scale(iris[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
print(hc)
# Affichage du dendrogramme
plot(hc, labels = iris$Species, main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, iris$Species)
# Exemple avec les données iris
data("agriculture")
iris_data <- scale(agriculture[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
print(hc)
# Affichage du dendrogramme
plot(hc, labels = row.names(agriculture), main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, iris$Species)
# Exemple avec les données iris
data("agriculture")
iris_data <- scale(agriculture[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(iris_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
print(hc)
# Affichage du dendrogramme
plot(hc, labels = row.names(agriculture), main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, row.names(agriculture))
# Exemple avec les données iris
data("agriculture")
agr_data <- scale(agriculture[, -5]) # Normalisation des données
# Calcul de la matrice de distance
d <- dist(agr_data, method = "euclidean")
print(d)
# Classification hiérarchique avec Ward
hc <- hclust(d, method = "ward.D2")
print(hc)
# Affichage du dendrogramme
plot(hc, labels = row.names(agriculture), main = "Dendrogramme de la CAH")
# Découpage en 3 clusters
clusters <- cutree(hc, k = 3)
table(clusters, row.names(agriculture))
###**Q1**
summary(iris)
(iris)
###**Q2**
iris.data <- iris[,1:4]
iris.specie <- iris[,5]
d <- dist(iris.data)
cah <- hclust(d,method="ward.D")
plot(cah, hang=-1)
plot(cah, hang=-1)
library(Nbclust)
library(NbClust)
shiny::runApp('D:/Home/ydiakite/Desktop/VISU/ShinyProjet/Dashbord_inst_elec')
setwd("D:/Home/ydiakite/Desktop/VISU/ShinyProjet/Dashboard_Installation_Electrique_France")
shiny::runApp()
runApp()
rsconnect::authorizeAccount("shinyapps.io")
install.packages('rsconnect')
rsconnect::setAccountInfo(name='diakiteyoussouf', token='2D5DAAAA5D13BE3423116899ADD0A1F4', secret='C2BV1lytCqHkoWo8wWbhRwkKhQIFLYC7HVKWKHbz')
rsconnect::setAccountInfo(name='diakiteyoussouf', token='2D5DAAAA5D13BE3423116899ADD0A1F4', secret='C2BV1lytCqHkoWo8wWbhRwkKhQIFLYC7HVKWKHbz')
runApp()
runApp()
runApp()
